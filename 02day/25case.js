// 通过require 可以加载系统模块与可以加载文件模块
// 
// require本身是以个函数  传递不停地参数 执行结果不同
// 
// 
// 1. 如果传入的字符串没有以 . ./ ../这样的开头就是系统模块加载
// 
// 以往认为路径不写会默认 ./进行解析
// require('./23-cart.js');
// 2. nodejs 会自动将.js 结尾的文件视为模块
// 所以在使用nrequire 加载模块时可以省略 .js 后缀
// 
// 
// require('./23-cart');
// let users = require ('24users');
// console.log(users);



// 关于require 加载模块 课可以分成更多情况
// 3. 当目录中存在node_modules 这样一个特殊目录是 在使用require 时 
// 如果没有 ./  ../时会有限去node_modules  下查找 如果查找不到就会去父级目录下查找
// 有没有 node_modules  如果存在 那么在这个的父级下查找 一直没有找到node_modules 
// 才会被认为是系统模块 （一层一层找）
// 
// 
// 4. 也可以将模块拆分成若干个小文件 将这些小文件放到同一个目录下 那么这个目录就是一个模块了
//在加载模块时 nodejs可以省略后缀 但是也会导致歧义 
//
//可以理解成当前的目录 也可以理解成当前下的文件 
//遇到这种情况是nodejs 会优先当成目录来对待 再去查找目录中有没有index.js
//  如果没有 那么当成目录加载失败 再当成文件加载

// require (); 
// 
// 模块也是包
// 当将多个文件放在同一目录下是 需要对模块进行说明 
// 通常将模块兴县的称为包 当需要对包进行说明时 需要通过一个文件进行说明 称为 包说明文件 
// /并这个文件通常有一个固定的文件名称package.json
// 在这个描述文件找那个可以写任意内容只要符合接送语法 但是有几项是必须的
// 版本version 名称name 作者auther  等等
// 
// 这个文件可以手工 可以通过命令创建 一般都是命令 
// 当时用命令创建时 需要在包的根目录下执行 npm init
// 
// 当 文件中不包含index.js 时 会使用main字段为指定入口
// 






// 仅仅以.js结尾的 不能完全意义上称为一个模块 只是nidejs将其对待成一模块 
// 作为开发需要真正对功能进行封装 并能够提供给其他开发者调用
// 
// function addCart(){
	// console.log('添加成功');
// }
// 
// 仅仅将方法定义还不行 还要讲这些函数公开出去 return 不符合语法 
// 所以nodejs新增了一个专门负责将内部函数或变量公开出去的歌对象 moudle.exports
// 
// var module = {};
// module.exports = {};  //自定义属性
// 
// 
// 
// 
// 在nodejs中除了使用module.exports外 有提供了一个exports来实现类似于module.exports类似功能
//exports 是一种简写 还是有差别
// 
// 
// 